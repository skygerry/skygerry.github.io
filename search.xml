<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode3(无重复字符的最长子串)]]></title>
    <url>%2F2019%2F05%2F27%2FLeetCode3%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路采用滑动窗口的方法来解决。从第一个字符开始循环，并把字符放到map中，如果 s[j]在 [i, j) 范围内有与 j’重复的字符，我们不需要逐渐增加 i。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 代码实现1234567891011121314151617181920212223242526class FirstSolution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int max = 0; Map&lt;Character, Integer&gt; characterIntegerMap = new HashMap&lt;&gt;(); for (int i = 0, j = 0; j &lt; n; j++) &#123; if (characterIntegerMap.containsKey(s.charAt(j))) &#123; i = Math.max(characterIntegerMap.get(s.charAt(j)), i); &#125; max = Math.max(max, j - i + 1); characterIntegerMap.put(s.charAt(j), j + 1); &#125; return max; &#125;&#125;public class ByteDanceFirst &#123; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入字符串："); String s = scanner.next(); int ret = new FirstSolution().lengthOfLongestSubstring(s); String out = String.valueOf(ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
</search>
