<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode33(搜索旋转排序数组)]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode33%2F</url>
    <content type="text"><![CDATA[题目：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 解题思路因为时间复杂度是O(log n)，所以采用二分查找来做。 代码实现12345678910111213141516171819202122232425262728293031323334class NinethSolution &#123; public int search(int[] nums, int target) &#123; if(nums==null||nums.length&lt;1) return -1; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; //如果中间值比最左边的值大 if (nums[mid] &gt;= nums[left]) &#123; //如果需要找的值比中间值小，并且比最左边的值大 if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) &#123; //right变为中间值的位置-1 right = mid - 1; &#125;else &#123; //left变为中间值的位置+1 left = mid + 1; &#125; &#125; //如果中间值比最右边的值小 if (nums[mid] &lt;= nums[right]) &#123; //如果需要找的值比中间值大，并且比最右边的值小 if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; //left变为中间值的位置+1 left = mid + 1; &#125;else &#123; //right变为中间值的位置-1 right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode695(岛屿的最大面积)]]></title>
    <url>%2F2019%2F06%2F04%2FLeetCode695%2F</url>
    <content type="text"><![CDATA[题目：给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回6。 注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路遍历循环到一个位置是1的点，然后通过深度搜索这个点的周边1的点，进行统计，并将统计过的位置变成0，防止重复统计。 代码实现1234567891011121314151617181920212223class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int max = 0; for(int i = 0;i &lt; grid.length;i++)&#123; for(int j = 0;j &lt; grid[0].length;j++)&#123; if(grid[i][j] == 1)&#123; int num = getIslandArea(grid,i,j); max = Math.max(num,max); &#125; &#125; &#125; return max; &#125; public int getIslandArea(int[][] grid,int i,int j)&#123; if(i&gt;=0&amp;&amp;i&lt;grid.length&amp;&amp;j&gt;=0&amp;&amp;j&lt;grid[0].length&amp;&amp;grid[i][j] == 1)&#123; grid[i][j]=0; int num = 1 + getIslandArea(grid,i-1,j) + getIslandArea(grid,i+1,j) + getIslandArea(grid,i,j-1) + getIslandArea(grid,i,j+1); return num; &#125;else return 0; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode15(三数之和)]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode15%2F</url>
    <content type="text"><![CDATA[题目：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解题思路for循环，nums[i],left从头开始，right从尾开始，如果 nums[i] + nums[left] + nums[right] &gt; 0，right–，如果小于0，left++，如果 num[left] = nums[left-1] 或者是 nums[right] = nums[right+1] 则跳过 代码实现1234567891011121314151617181920212223242526272829303132class SeventhSolution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = nums.length - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] + nums[i] &gt; 0) &#123; right--; &#125; else if (nums[left] + nums[right] + nums[i] &lt; 0) &#123; left++; &#125; else &#123; result.add(Arrays.asList(nums[left], nums[right], nums[i])); left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; left++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; right--; &#125; &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode71(简化路径)]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode71%2F</url>
    <content type="text"><![CDATA[题目：以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1： 输入：&quot;/home/&quot; 输出：&quot;/home&quot; 解释：注意，最后一个目录名后面没有斜杠。 示例 2： 输入：&quot;/../&quot; 输出：&quot;/&quot; 解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3： 输入：&quot;/home//foo/&quot; 输出：&quot;/home/foo&quot; 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4： 输入：&quot;/a/./b/../../c/&quot; 输出：&quot;/c&quot; 示例 5： 输入：&quot;/a/../../b/../c//.//&quot; 输出：&quot;/c&quot; 示例 6： 输入：&quot;/a//b////c/d//././/..&quot; 输出：&quot;/a/b/c&quot; 解题思路先将字符串按照”/“分解成字符串数组，然后将数组往栈中放，当遇到”..”的时候，将栈顶的数据抛出。 代码实现1234567891011121314151617class SixthSolution &#123; public String simplifyPath(String path) &#123; String[] arr = path.trim().split("/"); Stack&lt;String&gt; resultStack = new Stack&lt;&gt;(); for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i].equals("..")) &#123; if (!resultStack.isEmpty()) &#123; resultStack.pop(); &#125; &#125; else if (!arr[i].equals(".") &amp;&amp; !arr[i].isEmpty()) &#123; resultStack.add(arr[i]); &#125; &#125; StringBuilder stringBuilder = new StringBuilder("/"); return String.valueOf(stringBuilder.append(String.join("/", resultStack))); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode151(翻转字符串里的单词)]]></title>
    <url>%2F2019%2F05%2F31%2FLeetCode151%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 输入: &quot;the sky is blue&quot; 输出: &quot;blue is sky the&quot; 示例 2： 输入: &quot; hello world! &quot; 输出: &quot;world! hello&quot; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 输入: &quot;a good example&quot; 输出: &quot;example good a&quot; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 代码实现1234567891011121314151617class FifthSolution &#123; public String reverseWords(String s) &#123; String[] arr = s.trim().split("\\s+"); Collections.reverse(Arrays.asList(arr)); return String.join(" ", arr).trim(); &#125;&#125;public class ByteDanceFifth &#123; public static void main(String[] args) &#123; System.out.println("请输入字符串："); Scanner scanner1 = new Scanner(System.in); String s = scanner1.nextLine(); String x = new FifthSolution().reverseWords(s); System.out.println(x); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode43(字符串相乘)]]></title>
    <url>%2F2019%2F05%2F30%2FLeetCode43%2F</url>
    <content type="text"><![CDATA[题目：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = &quot;2&quot;, num2 = &quot;3&quot; 输出: &quot;6&quot; 示例 2: 输入: num1 = &quot;123&quot;, num2 = &quot;456&quot; 输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路 先算num1和num2的长度 两数相乘，最大长度为2个值的长度和，所以创建一个数组，长度为两个字符串的长度和 从num2的个位开始，依次和num1的每一位相乘，个位的位置为i+j+1，进位的位置为i+j，将个位和进位依次放入数组，个位是相乘的结果加上要放入的位置的值的和的个位，进位的位置是在原数据的基础上加上进位的值。最后输出字符串 解题例子789 * 256 数值：num1 = 789， num2 = 256 长度：n1 = 3，n2 = 3 相乘之后的答案的长度最大为6，所以，数组result[]长度为6 从256的最后一位开始，也就是6 j = 2，i = 2，那么个位位置为p2 = i + j + 1= 5，进位位置为p1 = i + j = 4 ， 6 * 9 + 0= 54 ，result = [ , , , ,5,4] j = 2，i = 1，那么个位位置为p2 = i + j + 1= 4，进位位置为p1 = i + j = 3 ， 6 * 8 + 5 = 53 ，result = [ , , ,5,3,4] j = 2，i = 0，那么个位位置为p2 = i + j + 1= 3，进位位置为p1 = i + j = 2 ， 6 * 7 + 5 = 47 ，result = [ , ,4,7,3,4] j = 1，i = 2，那么个位位置为p2 = i + j + 1= 4，进位位置为p1 = i + j = 3 ， 5 * 9 + 3 = 48 ，result = [ , ,4,11,8,4] j = 1，i = 1，那么个位位置为p2 = i + j + 1= 3，进位位置为p1 = i + j = 2 ， 5 * 8 + 11 = 51 ，result = [ , ,9,1,8,4] j = 1，i = 0，那么个位位置为p2 = i + j + 1= 2，进位位置为p1 = i + j = 1 ， 5 * 7 + 9 = 44 ，result = [ ,4,4,1,8,4] j = 0，i = 2，那么个位位置为p2 = i + j + 1= 3，进位位置为p1 = i + j = 2 ， 2 * 9 + 1 = 19 ，result = [ ,4,5,9,8,4] j = 0，i = 1，那么个位位置为p2 = i + j + 1= 2，进位位置为p1 = i + j = 1 ， 2 * 8 + 5 = 21 ，result = [ ,6,1,9,8,4] j = 0，i = 0，那么个位位置为p2 = i + j + 1= 1，进位位置为p1 = i + j = 0 ， 2 * 7 + 6 = 20 ，result = [2,0,1,9,8,4] 最终结果是201984 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class FourthSolution &#123; public String multiply(String num1, String num2) &#123; if (num1 == null || num1.length() == 0 || num2 == null || num2.length() == 0) &#123; return ""; &#125; int n1 = num1.length(); int n2 = num2.length(); if (n1 == 1 &amp;&amp; Integer.parseInt(num1) == 0) &#123; return num1; &#125; if (n2 == 1 &amp;&amp; Integer.parseInt(num2) == 0) &#123; return num2; &#125; int result[] = new int[n1 + n2]; for (int j = n2 - 1; j &gt;= 0; j--) &#123; for (int i = n1 - 1; i &gt;= 0; i--) &#123; int p1 = i + j; //每次 num2.charAt(j) * num1.charAt(i)的值的进位的问题 int p2 = i + j + 1; //每次 num2.charAt(j) * num1.charAt(i)的值的个位位置 int sum = (num2.charAt(j) - '0') * (num1.charAt(i) - '0') + result[p2]; result[p2] = sum % 10; //当前值的个位数字 result[p1] += sum / 10;//加上进位的值 &#125; &#125; StringBuilder finalResult = new StringBuilder(); for (int num : result) &#123; if (num == 0 &amp;&amp; finalResult.length() == 0) &#123; continue; &#125; finalResult.append(num); &#125; return finalResult.length() == 0 ? "0" : finalResult.toString(); &#125;&#125;public class ByteDanceFourth &#123; public static void main(String[] args) &#123; System.out.println("请输入第一个字符串："); Scanner scanner1 = new Scanner(System.in); String num1 = scanner1.next(); System.out.println("请输入第二个字符串："); Scanner scanner2 = new Scanner(System.in); String num2 = scanner2.next(); String x = new FourthSolution().multiply(num1, num2); System.out.println(x); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode567(字符串的排列)]]></title>
    <url>%2F2019%2F05%2F29%2FLeetCode567%2F</url>
    <content type="text"><![CDATA[题目：给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; 输出: True 解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2: 输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; 输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解题思路 s1的长度应该小于等于s2 首先我们知道，小写字母一共26个，那么，创建2个数组，数组长度为26，数组的0-25个位置代表a-z每个字母在字符串中出现的次数 先统计字符串s1中每个字母出现的次数 固定一个s1长度的滑动窗口，从s2字符串头开始，统计滑动窗口中字母出现的次数，如果和s1的数组一样，则包含s1的排列，如果不一样，则窗口往后滑动一位，继续统计字母出现次数，一直到和s1的数组一样，或者是滑动到结束。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243class ThirdSolution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1 == null || s2 == null || s1.length() &gt; s2.length()) &#123; return false; &#125; //s1每个字母出现的次数 int countA[] = new int[26]; //s2每个字母出现的次数 int countB[] = new int[26]; for (int i = 0; i &lt; s1.length(); i++) &#123; countA[s1.charAt(i) - 'a']++; countB[s2.charAt(i) - 'a']++; &#125; for (int i = s1.length(); i &lt; s2.length(); i++) &#123; if (Arrays.equals(countA, countB)) &#123; return true; &#125; //去掉滑块的首个字母的计数 countB[s2.charAt(i - s1.length()) - 'a']--; //添加最新的字母的计数到滑块中 countB[s2.charAt(i) - 'a']++; &#125; return Arrays.equals(countA, countB); &#125;&#125;public class ByteDanceThird &#123; public static void main(String[] args) &#123; System.out.println("请输入第一个字符串："); Scanner scanner1 = new Scanner(System.in); String a = scanner1.next(); System.out.println("请输入第二个字符串："); Scanner scanner2 = new Scanner(System.in); String b = scanner2.next(); boolean x = new ThirdSolution().checkInclusion(a, b); System.out.println(x); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DesignPattern(第一周:面向对象的六大原则)]]></title>
    <url>%2F2019%2F05%2F28%2FDesignPattern1%2F</url>
    <content type="text"></content>
      <categories>
        <category>每周设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode14(最长公共前缀)]]></title>
    <url>%2F2019%2F05%2F28%2FLeetCode14%2F</url>
    <content type="text"><![CDATA[题目：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 代码实现1234567891011121314151617181920212223242526272829303132333435363738class SecondSolution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return ""; for (int i = 0; i &lt; strs[0].length(); i++) &#123; char s = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != s) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0]; &#125;&#125;public class ByteDanceSecond &#123; public static void main(String[] args) &#123; System.out.println("请输入数组大小："); Scanner scanner1 = new Scanner(System.in); int num; num = scanner1.nextInt(); System.out.println("请输入序列："); Scanner scanner2 = new Scanner(System.in); String[] s = new String[num]; for (int i = 0; i &lt; num; i++) &#123; s[i] = scanner2.next(); &#125; String ret = new SecondSolution().longestCommonPrefix(s); String out = (ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode3(无重复字符的最长子串)]]></title>
    <url>%2F2019%2F05%2F27%2FLeetCode3%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路采用滑动窗口的方法来解决。从第一个字符开始循环，并把字符放到map中，如果 s[j]在 [i, j) 范围内有与 j’重复的字符，我们不需要逐渐增加 i。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 代码实现1234567891011121314151617181920212223242526class FirstSolution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int max = 0; Map&lt;Character, Integer&gt; characterIntegerMap = new HashMap&lt;&gt;(); for (int i = 0, j = 0; j &lt; n; j++) &#123; if (characterIntegerMap.containsKey(s.charAt(j))) &#123; i = Math.max(characterIntegerMap.get(s.charAt(j)), i); &#125; max = Math.max(max, j - i + 1); characterIntegerMap.put(s.charAt(j), j + 1); &#125; return max; &#125;&#125;public class ByteDanceFirst &#123; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入字符串："); String s = scanner.next(); int ret = new FirstSolution().lengthOfLongestSubstring(s); String out = String.valueOf(ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
</search>
