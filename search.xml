<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode567(字符串的排列)]]></title>
    <url>%2F2019%2F05%2F29%2FLeetCode567%2F</url>
    <content type="text"><![CDATA[题目：给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; 输出: True 解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2: 输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; 输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解题思路 s1的长度应该小于等于s2 首先我们知道，小写字母一共26个，那么，创建2个数组，数组长度为26，数组的0-25个位置代表a-z每个字母在字符串中出现的次数 先统计字符串s1中每个字母出现的次数 固定一个s1长度的滑动窗口，从s2字符串头开始，统计滑动窗口中字母出现的次数，如果和s1的数组一样，则包含s1的排列，如果不一样，则窗口往后滑动一位，继续统计字母出现次数，一直到和s1的数组一样，或者是滑动到结束。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243class ThirdSolution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1 == null || s2 == null || s1.length() &gt; s2.length()) &#123; return false; &#125; //s1每个字母出现的次数 int countA[] = new int[26]; //s2每个字母出现的次数 int countB[] = new int[26]; for (int i = 0; i &lt; s1.length(); i++) &#123; countA[s1.charAt(i) - 'a']++; countB[s2.charAt(i) - 'a']++; &#125; for (int i = s1.length(); i &lt; s2.length(); i++) &#123; if (Arrays.equals(countA, countB)) &#123; return true; &#125; //去掉滑块的首个字母的计数 countB[s2.charAt(i - s1.length()) - 'a']--; //添加最新的字母的计数到滑块中 countB[s2.charAt(i) - 'a']++; &#125; return Arrays.equals(countA, countB); &#125;&#125;public class ByteDanceThird &#123; public static void main(String[] args) &#123; System.out.println("请输入第一个字符串："); Scanner scanner1 = new Scanner(System.in); String a = scanner1.next(); System.out.println("请输入第二个字符串："); Scanner scanner2 = new Scanner(System.in); String b = scanner2.next(); boolean x = new ThirdSolution().checkInclusion(a, b); System.out.println(x); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DesignPattern(第一周:面向对象的六大原则)]]></title>
    <url>%2F2019%2F05%2F28%2FDesignPattern1%2F</url>
    <content type="text"></content>
      <categories>
        <category>每周设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode14(最长公共前缀)]]></title>
    <url>%2F2019%2F05%2F28%2FLeetCode14%2F</url>
    <content type="text"><![CDATA[题目：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 代码实现1234567891011121314151617181920212223242526272829303132333435363738class SecondSolution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return ""; for (int i = 0; i &lt; strs[0].length(); i++) &#123; char s = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != s) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0]; &#125;&#125;public class ByteDanceSecond &#123; public static void main(String[] args) &#123; System.out.println("请输入数组大小："); Scanner scanner1 = new Scanner(System.in); int num; num = scanner1.nextInt(); System.out.println("请输入序列："); Scanner scanner2 = new Scanner(System.in); String[] s = new String[num]; for (int i = 0; i &lt; num; i++) &#123; s[i] = scanner2.next(); &#125; String ret = new SecondSolution().longestCommonPrefix(s); String out = (ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode3(无重复字符的最长子串)]]></title>
    <url>%2F2019%2F05%2F27%2FLeetCode3%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路采用滑动窗口的方法来解决。从第一个字符开始循环，并把字符放到map中，如果 s[j]在 [i, j) 范围内有与 j’重复的字符，我们不需要逐渐增加 i。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 代码实现1234567891011121314151617181920212223242526class FirstSolution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int max = 0; Map&lt;Character, Integer&gt; characterIntegerMap = new HashMap&lt;&gt;(); for (int i = 0, j = 0; j &lt; n; j++) &#123; if (characterIntegerMap.containsKey(s.charAt(j))) &#123; i = Math.max(characterIntegerMap.get(s.charAt(j)), i); &#125; max = Math.max(max, j - i + 1); characterIntegerMap.put(s.charAt(j), j + 1); &#125; return max; &#125;&#125;public class ByteDanceFirst &#123; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入字符串："); String s = scanner.next(); int ret = new FirstSolution().lengthOfLongestSubstring(s); String out = String.valueOf(ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
</search>
