<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DesignPattern(第一周)]]></title>
    <url>%2F2019%2F05%2F28%2FDesignPattern1%2F</url>
    <content type="text"></content>
      <categories>
        <category>每周设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode14(最长公共前缀)]]></title>
    <url>%2F2019%2F05%2F28%2FLeetCode14%2F</url>
    <content type="text"><![CDATA[题目：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2: 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 代码实现1234567891011121314151617181920212223242526272829303132333435363738class SecondSolution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return ""; for (int i = 0; i &lt; strs[0].length(); i++) &#123; char s = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != s) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0]; &#125;&#125;public class ByteDanceSecond &#123; public static void main(String[] args) &#123; System.out.println("请输入数组大小："); Scanner scanner1 = new Scanner(System.in); int num; num = scanner1.nextInt(); System.out.println("请输入序列："); Scanner scanner2 = new Scanner(System.in); String[] s = new String[num]; for (int i = 0; i &lt; num; i++) &#123; s[i] = scanner2.next(); &#125; String ret = new SecondSolution().longestCommonPrefix(s); String out = (ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode3(无重复字符的最长子串)]]></title>
    <url>%2F2019%2F05%2F27%2FLeetCode3%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路采用滑动窗口的方法来解决。从第一个字符开始循环，并把字符放到map中，如果 s[j]在 [i, j) 范围内有与 j’重复的字符，我们不需要逐渐增加 i。我们可以直接跳过 [i，j’]范围内的所有元素，并将 i 变为 j’ + 1。 代码实现1234567891011121314151617181920212223242526class FirstSolution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int max = 0; Map&lt;Character, Integer&gt; characterIntegerMap = new HashMap&lt;&gt;(); for (int i = 0, j = 0; j &lt; n; j++) &#123; if (characterIntegerMap.containsKey(s.charAt(j))) &#123; i = Math.max(characterIntegerMap.get(s.charAt(j)), i); &#125; max = Math.max(max, j - i + 1); characterIntegerMap.put(s.charAt(j), j + 1); &#125; return max; &#125;&#125;public class ByteDanceFirst &#123; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入字符串："); String s = scanner.next(); int ret = new FirstSolution().lengthOfLongestSubstring(s); String out = String.valueOf(ret); System.out.print(out); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode每日算法</category>
      </categories>
  </entry>
</search>
