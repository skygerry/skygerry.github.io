<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>叶开的私有领地</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 01 Jul 2019 08:48:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode60(第K个排列)</title>
      <link>http://yoursite.com/2019/07/01/LeetCode60/</link>
      <guid>http://yoursite.com/2019/07/01/LeetCode60/</guid>
      <pubDate>Mon, 01 Jul 2019 05:40:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;给出集合[1,2,3,…,n]，其所有元素共有n! 种排列。&lt;br&gt;按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>给出集合[1,2,3,…,n]，其所有元素共有n! 种排列。<br>按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：<br>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定n 和k，返回第k个排列。</p><p>说明：<br>给定 n的范围是 [1, 9]。<br>给定 k的范围是[1, n!]。</p><p>示例1:<br>输入: n = 3, k = 3<br>输出: “213”</p><p>示例2:<br>输入: n = 4, k = 9<br>输出: “2314”</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>首先我们考虑使用全排列的方法，然后找到第k个，举个例子：n = 4, k = 9</li></ol><p>首先列出所有的排列<br>1234<br>1243<br>1324<br>1342<br>1423<br>1432<br>2134<br>2143<br>2314<br>2341<br>2413<br>2431<br>3124<br>3142<br>3214<br>3241<br>3412    <---->    k = 17<br>3421<br>4123<br>4132<br>4213<br>4231<br>4312<br>4321    </----></p><ol start="2"><li>全排列的方法太过于复杂，我们可以先找一下规律。</li></ol><blockquote><p> 首先，集合为[1,2,3,4]。我们可以发现，每个数字开头的排列个数都是(n-1)!，所以，我们可以通过k值来算出第一位的位置，因为k = 17对应的下标为16，所以，用 16 / 3! =  2，那么第一位应该是集合中的第二个数字3。然后剩下的 16 % 3! = 4。第二层是3个数字，每个数字的排列个数是2!，所以第二位是4 / 2！ = 2，因为3已经被取走，所以这个时候集合中的下标为2的数字是4。然后剩下的 4 % 2! = 0。第三层是2个数字，每个数字的排列个数是1!，所以第三位是 0 / 1! = 0，所以是1。最后是2。 结果是3412。</p></blockquote><ol start="3"><li>从2中的逻辑，我们可以得出</li></ol><p>k = k - 1</p><p>x1 = k / (n - 1)!<br>k1 = k % (n - 1)!</p><p>x2 = k1 / (n - 2)!<br>k2 = k1 % (n - 2)!<br>.<br>.<br>.<br>xn-1 = kn-2 / 1!<br>kn-1 = kn-2 / 1!</p><p>xn = kn-1 / 0!<br>kn = kn-1 % 0!</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirteenthSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">String numStr = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">num[i] = num[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line">--k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = k / num[n - i];</span><br><span class="line">k %= num[n - i];</span><br><span class="line">res.append(numStr.charAt(j));</span><br><span class="line">numStr = numStr.replace(numStr.charAt(j) + <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteDanceThirteenth</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(line);</span><br><span class="line">line = in.readLine();</span><br><span class="line"><span class="keyword">int</span> k = Integer.parseInt(line);</span><br><span class="line"></span><br><span class="line">String ret = <span class="keyword">new</span> ThirteenthSolution().getPermutation(n, k);</span><br><span class="line"></span><br><span class="line">String out = (ret);</span><br><span class="line"></span><br><span class="line">System.out.print(out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/07/01/LeetCode60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode128(最长连续序列)</title>
      <link>http://yoursite.com/2019/06/27/LeetCode128/</link>
      <guid>http://yoursite.com/2019/06/27/LeetCode128/</guid>
      <pubDate>Thu, 27 Jun 2019 06:27:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为O(n)。</p><p>示例:</p><p>输入:[100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>将 nums 数组中的每一个数字，作为序列第一个数字，枚举后面的数字，直到有数字在原数组中没出现过。当枚举到数组中没有的数字时（即 currentNum 是一个数组中没出现过的数字），记录下序列的长度，如果比当前最优解大的话就更新。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwelfthSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">numSet.add(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> longSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : numSet) &#123;</span><br><span class="line"><span class="keyword">if</span> (!numSet.contains(i - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> currentNum = i;</span><br><span class="line"><span class="keyword">int</span> currentSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (numSet.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">currentNum++;</span><br><span class="line">currentSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">longSize = Math.max(longSize, currentSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> longSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/27/LeetCode128/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode215(数组中的第K个最大元素)</title>
      <link>http://yoursite.com/2019/06/25/LeetCode215/</link>
      <guid>http://yoursite.com/2019/06/25/LeetCode215/</guid>
      <pubDate>Tue, 25 Jun 2019 02:09:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p><p>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>对整个数组进行从大到小的排序，然后取第K大的值</li><li>使用PriorityQueue来进行操作。PriorityQueue即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java 的优先队列每次取最小元素，C++ 的优先队列每次取最大元素）<a href="https://get233.com/archives/Java-Collections-PriorityQueue.html#menu_index_6" target="_blank" rel="noopener">PriorityQueue相关内容</a></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElevenSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (priorityQueue.size() &lt; k) &#123;</span><br><span class="line">priorityQueue.add(nums[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (priorityQueue.peek() &lt; nums[i]) &#123;</span><br><span class="line">priorityQueue.remove();</span><br><span class="line">priorityQueue.add(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/25/LeetCode215/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode674(最长连续递增序列)</title>
      <link>http://yoursite.com/2019/06/06/LeetCode674/</link>
      <guid>http://yoursite.com/2019/06/06/LeetCode674/</guid>
      <pubDate>Thu, 06 Jun 2019 06:50:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;给定一个未经排序的整数数组，找到最长且连续的的递增序列。

示例 1:
输入: [1,3,5,4,7]
输出: 3

        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><pre><code>给定一个未经排序的整数数组，找到最长且连续的的递增序列。示例 1:输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2:输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。注意：数组长度不会超过10000。</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>设置一个length 和 count，默认都为1<br>for循环，如果后一个值比前一个值大，则count值加1，如果小，则count重置为1。并和length相比，如果比length大，则将length的值替换为count的值，如果小，则length不变。最后输出length。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TenthSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; lenth) &#123;</span><br><span class="line">                lenth = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/06/LeetCode674/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode33(搜索旋转排序数组)</title>
      <link>http://yoursite.com/2019/06/05/LeetCode33/</link>
      <guid>http://yoursite.com/2019/06/05/LeetCode33/</guid>
      <pubDate>Wed, 05 Jun 2019 09:02:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><pre><code>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>因为时间复杂度是O(log n)，所以采用二分查找来做。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NinethSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//如果中间值比最左边的值大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="comment">//如果需要找的值比中间值小，并且比最左边的值大</span></span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) &#123;</span><br><span class="line">                    <span class="comment">//right变为中间值的位置-1</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//left变为中间值的位置+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果中间值比最右边的值小</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[right]) &#123;</span><br><span class="line">                <span class="comment">//如果需要找的值比中间值大，并且比最右边的值小</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    <span class="comment">//left变为中间值的位置+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//right变为中间值的位置-1</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/05/LeetCode33/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
