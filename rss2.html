<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>叶开的私有领地</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 09 Jul 2019 05:43:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode547(朋友圈)</title>
      <link>http://yoursite.com/2019/07/02/LeetCode547/</link>
      <guid>http://yoursite.com/2019/07/02/LeetCode547/</guid>
      <pubDate>Tue, 02 Jul 2019 05:24:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;班上有N名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知A是B的朋友，B是C的朋友，那么我们可以认为A也是C的
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>班上有N名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知A是B的朋友，B是C的朋友，那么我们可以认为A也是C的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个N * N的矩阵M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:<br>输入:<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>输出: 2<br>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回2。</p><p>示例 2:<br>输入:<br>[[1,1,0],<br>[1,1,1],<br>[0,1,1]]<br>输出: 1<br>说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>注意：</p><p>N 在[1,200]的范围内。<br>对于所有学生，有M[i][i] = 1。<br>如果有M[i][j] = 1，则有M[j][i] = 1。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>采用深度搜索的方式，一层一层的去查找相邻的学生</li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourteenthSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;<span class="comment">//使用深度优先搜索，类似岛屿个数的题目</span></span><br><span class="line"><span class="keyword">int</span> length = M.length;<span class="comment">//二维数组长度，即所有人的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//统计朋友圈个数</span></span><br><span class="line"><span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];<span class="comment">//访问标志</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;<span class="comment">//对于每个人</span></span><br><span class="line"><span class="keyword">if</span> (flag[i] == <span class="keyword">false</span>) &#123;<span class="comment">//如果未被访问</span></span><br><span class="line">DFS(i, M, flag);<span class="comment">//深度优先搜索，访问</span></span><br><span class="line">count++;<span class="comment">//朋友圈个数+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[][] M, <span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">flag[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[j] == <span class="keyword">false</span> &amp;&amp; M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">DFS(j, M, flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/07/02/LeetCode547/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ComputerNetWorking1(计算机网络和因特网)</title>
      <link>http://yoursite.com/2019/07/01/ComputerNetWorking1/</link>
      <guid>http://yoursite.com/2019/07/01/ComputerNetWorking1/</guid>
      <pubDate>Mon, 01 Jul 2019 09:41:45 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://yoursite.com/2019/07/01/ComputerNetWorking1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode60(第K个排列)</title>
      <link>http://yoursite.com/2019/07/01/LeetCode60/</link>
      <guid>http://yoursite.com/2019/07/01/LeetCode60/</guid>
      <pubDate>Mon, 01 Jul 2019 05:40:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;给出集合[1,2,3,…,n]，其所有元素共有n! 种排列。&lt;br&gt;按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>给出集合[1,2,3,…,n]，其所有元素共有n! 种排列。<br>按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：<br>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定n 和k，返回第k个排列。</p><p>说明：<br>给定 n的范围是 [1, 9]。<br>给定 k的范围是[1, n!]。</p><p>示例1:<br>输入: n = 3, k = 3<br>输出: “213”</p><p>示例2:<br>输入: n = 4, k = 9<br>输出: “2314”</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>首先我们考虑使用全排列的方法，然后找到第k个，举个例子：n = 4, k = 9</li></ol><p>首先列出所有的排列<br>1234<br>1243<br>1324<br>1342<br>1423<br>1432<br>2134<br>2143<br>2314<br>2341<br>2413<br>2431<br>3124<br>3142<br>3214<br>3241<br>3412    <---->    k = 17<br>3421<br>4123<br>4132<br>4213<br>4231<br>4312<br>4321    </----></p><ol start="2"><li>全排列的方法太过于复杂，我们可以先找一下规律。</li></ol><blockquote><p> 首先，集合为[1,2,3,4]。我们可以发现，每个数字开头的排列个数都是(n-1)!，所以，我们可以通过k值来算出第一位的位置，因为k = 17对应的下标为16，所以，用 16 / 3! =  2，那么第一位应该是集合中的第二个数字3。然后剩下的 16 % 3! = 4。第二层是3个数字，每个数字的排列个数是2!，所以第二位是4 / 2！ = 2，因为3已经被取走，所以这个时候集合中的下标为2的数字是4。然后剩下的 4 % 2! = 0。第三层是2个数字，每个数字的排列个数是1!，所以第三位是 0 / 1! = 0，所以是1。最后是2。 结果是3412。</p></blockquote><ol start="3"><li>从2中的逻辑，我们可以得出</li></ol><p>k = k - 1</p><p>x1 = k / (n - 1)!<br>k1 = k % (n - 1)!</p><p>x2 = k1 / (n - 2)!<br>k2 = k1 % (n - 2)!<br>.<br>.<br>.<br>xn-1 = kn-2 / 1!<br>kn-1 = kn-2 / 1!</p><p>xn = kn-1 / 0!<br>kn = kn-1 % 0!</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirteenthSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">String numStr = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">num[i] = num[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line">--k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = k / num[n - i];</span><br><span class="line">k %= num[n - i];</span><br><span class="line">res.append(numStr.charAt(j));</span><br><span class="line">numStr = numStr.replace(numStr.charAt(j) + <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteDanceThirteenth</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(line);</span><br><span class="line">line = in.readLine();</span><br><span class="line"><span class="keyword">int</span> k = Integer.parseInt(line);</span><br><span class="line"></span><br><span class="line">String ret = <span class="keyword">new</span> ThirteenthSolution().getPermutation(n, k);</span><br><span class="line"></span><br><span class="line">String out = (ret);</span><br><span class="line"></span><br><span class="line">System.out.print(out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/07/01/LeetCode60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode128(最长连续序列)</title>
      <link>http://yoursite.com/2019/06/27/LeetCode128/</link>
      <guid>http://yoursite.com/2019/06/27/LeetCode128/</guid>
      <pubDate>Thu, 27 Jun 2019 06:27:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为O(n)。</p><p>示例:</p><p>输入:[100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>将 nums 数组中的每一个数字，作为序列第一个数字，枚举后面的数字，直到有数字在原数组中没出现过。当枚举到数组中没有的数字时（即 currentNum 是一个数组中没出现过的数字），记录下序列的长度，如果比当前最优解大的话就更新。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwelfthSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">numSet.add(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> longSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : numSet) &#123;</span><br><span class="line"><span class="keyword">if</span> (!numSet.contains(i - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> currentNum = i;</span><br><span class="line"><span class="keyword">int</span> currentSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (numSet.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">currentNum++;</span><br><span class="line">currentSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">longSize = Math.max(longSize, currentSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> longSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/27/LeetCode128/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode215(数组中的第K个最大元素)</title>
      <link>http://yoursite.com/2019/06/25/LeetCode215/</link>
      <guid>http://yoursite.com/2019/06/25/LeetCode215/</guid>
      <pubDate>Tue, 25 Jun 2019 02:09:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h5 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h5&gt;&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p><p>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>对整个数组进行从大到小的排序，然后取第K大的值</li><li>使用PriorityQueue来进行操作。PriorityQueue即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java 的优先队列每次取最小元素，C++ 的优先队列每次取最大元素）<a href="https://get233.com/archives/Java-Collections-PriorityQueue.html#menu_index_6" target="_blank" rel="noopener">PriorityQueue相关内容</a></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElevenSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (priorityQueue.size() &lt; k) &#123;</span><br><span class="line">priorityQueue.add(nums[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (priorityQueue.peek() &lt; nums[i]) &#123;</span><br><span class="line">priorityQueue.remove();</span><br><span class="line">priorityQueue.add(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/25/LeetCode215/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
